# Section 10: Parser Generators

In this lab, you'll be working with `ocamllex` (a lexer generator) and `menhir` (a parser generator) to lex and parse an arithmetic language. A **parser generator** takes in a context-free grammar as input and generates a parser for the language defined by that grammar automatically. You may not have noticed, but our in-class compiler uses a parser generator itself (`menhir`)! Take a peek at `s_exp/parse.mly` to see the definition of the grammar for our Lisp-like language.

Parser generators are an excellent tool to have in your toolbox. While many languages today use handwritten parsers—largely because of the extra control they provide over design choices like error reproting—many still use parser generators. Examples include Ruby, Bash, R, CPython, SQLite, [and more](https://notes.eatonphil.com/parser-generators-vs-handwritten-parsers-survey-2021.html)!

## Resources

Here are some helpful resources for today's lab and for future reading for the curious:

- [Menhir manual](http://gallium.inria.fr/~fpottier/menhir/manual.html)
- [Real World OCaml chapter on lexing and parsing](https://dev.realworldocaml.org/parsing-with-ocamllex-and-menhir.html)

## Getting started

For this lab, you will not need to modify any files in the `bin/` or `lib/` directory; we will be focused solely on the `syntax/` directory, which is where we will build our lexer and parser.

To start, we've provided a lexer (`syntax/lex.mll`) and parser (`syntax/parse.mly`) for a simple language supporting integers, infix addition, and a `print` operator. Programs in this language are composed of statements of the form `print <expr>` followed by a newline, semicolon, or EOF character. For example, the following are valid programs as of now:

```
print 1
```

```
print 1 + 2
```

```
print 2; print 3
```

```
print 1 + 2
print 4
```

### Running the interpreter

To run the interpreter, execute the `interp` binary as follows:

```
dune exec ./bin/interp.exe -- -e "<PROGRAM>"
```

This will parse the program `<PROGRAM>` with your parser and interpret the AST that is produced. For instance, you could use the following to test the starter code:

```
dune exec ./bin/interp.exe -- -e "print 1 + 2"
```

Once the programs you want to run become more complex, it'll be easier to write them as files. To run the interpreter on a file, execute:

```
dune exec ./bin/interp.exe -- <FILE>
```

### Inspecting the parse tree generated by `menhir`

Sometimes, you may want to examine the parse tree for a given program. To do this, you can use `menhir` as an interpreter and direct it to print the parse tree (also called the `concrete syntax tree` or CST) for a given sequence of tokens. To do this, run the following command:

```sh
menhir --interpret --interpret-show-cst syntax/parse.mly
```

This will enter you into the `menhir` interpreter. You can then enter a series of tokens representing the program in your language. For example, to see the parse tree for `print 1 + 2`, you can enter `PRINT NUMBER PLUS NUMBER`. This should produce output like the following:

```sh
ACCEPT
[main:
  [stmt:
    PRINT
    [expr: [expr: [literal: NUMBER]] PLUS [literal: NUMBER]]
  ]
  EOF
]
```

## Part 1: Extending the language

Extend the lexer and parser to support the following new forms. To do so, you will need to modify the lexer in `lex.mll` to transform specific sequences of one or more characters into tokens. Additionally, you will need to define a context-free grammar in `parse.mly` to transform these tokens into an AST. As you go, note when you need to modify the lexer and when you need to modify the parser!

### Associativity

In tasks 1.1 – 1.5 below, you will add support for lexing and parsing arithmetic operators to your language. These operators should follow two associativity constraints:

1. `-`, `*`, and `/` should be left-associative (similar to `+`)
  - When used for negation, `-` should be non-associative
2. `^` should be right-associative (i.e. `2 ^ 3 ^ 4 = 2 ^ (3 ^ 4)`)

### Precedence

Of all the operators, `log`, `sin`, `cos`, `tan`, and negation should have the highest precedence, followed by exponentiation, then multiplication and division, then addition and subtraction.

_Note:_ Don't use `%left`, `%right`, `%nonassoc`, or `%prec` declarations yet, since we'll be using them in the next part! Instead, you should encode associativity and precedence explicitly using production rules, similar to how we've encoded the left-associativity of addition.

_Hint:_ You want to define different production rules for each level of precedence!

### Tasks

**Task 1.1**: Add support for **float literals** (e.g. `1.23`) and **scientific notation literals** (e.g. `3.47e5`, which is equivalent to `3.47 * 10^5 = 347000`).

_Hint:_ For scientific notation literals, OCaml's `float_of_string` function will accept these literals as input, so you just have to extend the number rule in the lexer to recognize the new literal form.

**Task 1.2**: Add support for  `-`, `*`, `/`, and `^` (exponentiation) binary infix operators (e.g. `5 - 3`, `1 * 2`, `4 / 2`, `2 ^ 3`). `-` should also be usable as a unary prefix operator for negation (e.g. `-5`).

_Hint:_ Make sure to look at `syntax/ast.ml` to see which AST node names are valid for the `expr` type. Your definition in `parse.mly` for each token should map to one of these AST nodes.

**Task 1.3**: Add support for prefix `log`, `sin`, `cos`, `tan` operators (e.g. `log 5`).

**Task 1.4**: Add support `(` and `)` to group expressions (e.g. `print (1 + 2) * 3`).

**Task 1.5**: Add support for variable assignments, which should correspond to `Assign` nodes in the AST (e.g. `foo = 1`). Take note of the following restrictions on variables:
  - Variable names may contain letters, underscores, or numbers, but must start with a letter
  - The statements that make up a program may now either be `print` statements or variable assignments

## Part 2: Simplifying the parser

Next, we'll be simplifying the parser using some of Menhir's useful features. **Before beginning work on this section, save a copy of `parse.mly`—you'll need it again for Part 3.**

Using Menhir's `%left`, `%right`, and `%nonassoc` declarations (see the Menhir manual linked above and note that it calls precedence "priority"), establish the same associativity and precedence rules for the operators in our language. This should reduce the number of parse rules you need to represent the language.

_Hint:_ You may need to use the `%prec` declaration to override the precedence of the `-` operator when it is used for negation.

## Challenge: Implicit multiplication

When writing mathematical expressions in non-programming contexts, it's common to write expressions like `3 (4 + 5)` to implicitly mean `3 * (4 + 5)`. Add support for this form of expressions to your parser, converting them into the same ASTs that the explicit forms would parse to. For example, the previous example should be converted to the AST `Times (Num 3) (Plus (Num 4) (Num 5))`.

In order to add support for this form of expression in the parse rules, we'll need to go back to manually describing precedence and associativity instead of using Menhir's succinct declarations, so swap your current `parse.mly` file with the copy saved at the beginning of Part 2. The reason for this is that Menhir's precedence and associativity hints help the parser generator resolve shift-reduce conflicts. There's a set of rules that it uses to do this and they involve looking at the token being parsed (e.g. `PLUS`). In the case of implicit multiplication, however, there isn't any such token to look at.
